// @generated by protobuf-ts 2.8.1
// @generated from protobuf file "sce.proto" (package "sce", syntax proto3)
// tslint:disable
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { SCE } from "./sce";
import type { InlineResponse } from "./sce";
import type { InlineRequest } from "./sce";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { SliceResponse } from "./sce";
import type { SliceRequest } from "./sce";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * @generated from protobuf service sce.SCE
 */
export interface ISCEClient {
    /**
     * @generated from protobuf rpc: Slice(sce.SliceRequest) returns (sce.SliceResponse);
     */
    slice(input: SliceRequest, options?: RpcOptions): UnaryCall<SliceRequest, SliceResponse>;
    /**
     * / Request to inline the given target function at the given call site.
     * / N.B. Some LSPs support inlining already (see https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#:~:text=constant%0A%09%20*%20%2D%20...%0A%09%20*\/%0A%09export%20const-,RefactorInline,-%3A%20CodeActionKind%20%3D)
     * / however many don't (notably clangd/any C(++) LSP I can find),
     * / so this still provides one (albeit a "simpler" AST-based approach).
     *
     * @generated from protobuf rpc: Inline(sce.InlineRequest) returns (sce.InlineResponse);
     */
    inline(input: InlineRequest, options?: RpcOptions): UnaryCall<InlineRequest, InlineResponse>;
}
/**
 * @generated from protobuf service sce.SCE
 */
export class SCEClient implements ISCEClient, ServiceInfo {
    typeName = SCE.typeName;
    methods = SCE.methods;
    options = SCE.options;
    constructor(private readonly _transport: RpcTransport) {
    }
    /**
     * @generated from protobuf rpc: Slice(sce.SliceRequest) returns (sce.SliceResponse);
     */
    slice(input: SliceRequest, options?: RpcOptions): UnaryCall<SliceRequest, SliceResponse> {
        const method = this.methods[0], opt = this._transport.mergeOptions(options);
        return stackIntercept<SliceRequest, SliceResponse>("unary", this._transport, method, opt, input);
    }
    /**
     * / Request to inline the given target function at the given call site.
     * / N.B. Some LSPs support inlining already (see https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#:~:text=constant%0A%09%20*%20%2D%20...%0A%09%20*\/%0A%09export%20const-,RefactorInline,-%3A%20CodeActionKind%20%3D)
     * / however many don't (notably clangd/any C(++) LSP I can find),
     * / so this still provides one (albeit a "simpler" AST-based approach).
     *
     * @generated from protobuf rpc: Inline(sce.InlineRequest) returns (sce.InlineResponse);
     */
    inline(input: InlineRequest, options?: RpcOptions): UnaryCall<InlineRequest, InlineResponse> {
        const method = this.methods[1], opt = this._transport.mergeOptions(options);
        return stackIntercept<InlineRequest, InlineResponse>("unary", this._transport, method, opt, input);
    }
}
